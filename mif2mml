#!/usr/bin/perl

use strict;
use warnings;

use utf8; # lots of funky chars in here

use Getopt::Std;

my %opt;
getopts( 'nspvce', \%opt);

if( $opt{p}) { $opt{s}=1; }

use XML::Twig;
use Parse::RecDescent;

my $DPI= 300; # dpi for the png output

sub svg2png  { my $file= shift; (inkscape => '-e' => filename( png => $file), '-d' => $DPI,  filename( svg => $file)) }

# choose the tool you are using to generate the SVG
sub mml2svg { my $file= shift; (python => '/usr/local/src/svgmath/math2svg.py' => '-s', '-o' =>  filename( svg => $file), filename( mml => $file)) }
#sub mml2svg  { my $file= shift; (mathmlsvg => filename( mml => $file)) }

my $grammar=<<'G';
{
my %ent=
    ( # p 182-184 of the MIF reference Manual
      aleph     => 'א', alpha     => 'α', beta      => 'β', bot       => '⊥', chi       => 'χ', cpartial  => '∂',
      degree    => '°', delta     => 'δ', Delta     => '∆', emptyset  => '∅', epsilon   => 'ε', eta       => 'η',
      gamma     => 'γ', Gamma     => 'Γ', Im        => '𝔍', infty     => '∞', iota      => 'ι', kappa     => 'κ',
      lambda    => 'λ', Lambda    => 'Λ', ldots     => '…', mu        => 'μ', nabla     => '∇', nu        => 'ν',
      omega     => 'ω', Omega     => 'Ω', phi       => 'φ', Phi       => 'Φ', pi        => 'π', Pi        => 'Π',
      pprime    => '″', prime     => '′', psi       => 'ψ', Psi       => 'Ψ', Re        => 'R', rho       => 'ρ',
      sigma     => 'σ', Sigma     => 'Σ', tau       => 'τ', theta     => 'θ', Theta     => 'Θ', upsilon   => 'υ',
      Upsilon   => 'Υ', varphi    => 'φ', varpi     => 'π', varsigma  => 'ς', vartheta  => 'θ', wp        => '℘',
      xi        => 'ξ', Xi        => 'Ξ', zeta      => 'ζ',
      # p 186-189 of the MIF reference Manual
      leq       => '≤', geq       => '≥', lessthan  => '&lt;', notequal  => '≠', greaterthan => '&gt;',
      infty     => '∞', rarr      => '→', caret     =>'‸', tprime    => '‴', rabracket => '›', labracket => '‹',
      tie       => '⁀', overline  => '‾', dagger    => '†', geq       => '≥', leq       => '≤', sum       => '∑',
      int       => '∫', dot       => '⋅', twodots   => '‥', ellip     => '…', box       => '□', angle     => '∠',
      bullet    => '•', times     => '⨉', exists    => '∃', forall    => '∀', minusplus => '∓', plusminus => '±',
      neg       => '¬', therefore => '∴',
      topcurly  => '︷', bottomcurly => '︸', 
    );
      

# to replace characters in the symbol font by the real character - from http://www.alanwood.net/demos/symbol.html
# I have only included greek characters, as they are the only ones I have seen used
my %symbol=
    ( a => 'α', b => 'β', c => 'χ', d => 'δ', e => 'ε', f => 'φ', g => 'γ', h => 'η', i => 'ι', j => 'ϕ', k => 'κ', l => 'Λ',  m => 'μ',
      n => 'ν', o => 'ο', p => 'π', q => 'θ', r => 'ρ', s => 'σ', t => 'τ', u => 'υ', v => 'ϖ', w => 'ω', x => 'ξ', y => 'ψ', z => 'ζ',
      D => 'Δ', F => 'Φ', G => 'Γ', J => 'ϑ', L => 'Λ', P => 'Π', Q => 'Θ', S => 'Σ',  U => 'Υ', V => 'ς', Y => 'Ψ', W => 'Ω', 
      O => 'Ω', # not sure about that
    );
# to replace escaped characters in strings or chars
my %frame_escape=
    ( t      => "\t", '>' => '>', q => "'", Q => '`', '\\' => '\\', # p 7 of the MIF reference Manual
      'xd0 ' => '–',                                              # found this in an equation, don't know why d0 is a dash
    );

# that's what the MIF reference calls "formatting codes"
my $format='';  # last found format, global because it is quite cumbersome to pass it around even though most of the time it is not needed

# nodes (operators in the MIF Reference)

# these types of node require specific processing
my %special=
  ( times => sub { mrow( @_); },
    id          => \&id,
    chem        => \&chem,  
    tensor      => \&tensor,  
    matrix      => \&matrix,  
    lparen      => \&lparen,
    rparen      => \&rparen,
    indexes     => \&indexes,
    diacritical => \&decoration,
    ast         => sub { mrow( msup( $_[0], mo('∗'))); },
    box2        => sub { mrow( msup( mi($ent{box}), mi(2)), @_); },
    downbrace   => sub { mover( mrow( $_[0]), mo( $ent{topcurly})); },
    lap         => sub { mrow( msup( mi($ent{nabla}), mi(2)), @_); },
    overline    => sub { mover( shift(), mo( $ent{overline})); },
    upbrace     => sub { munder( mrow( $_[0]), mo( $ent{bottomcurly})); },
    acmut       => sub { mfenced( [ '{', '}', ','], @_); },
    bket        => sub { mfenced( [ '〈', '〉', '|'], @_); },
    cmut        => sub { mfenced( [ '[', ']', ','], @_); },
    inprod      => sub { mfenced( @_); },
    choice      => sub { mfenced( mfrac( { linethickness => 0 }, @_)); },
    function    => sub { mrow( shift() . mfenced( @_)); },
    lim         => sub { munder( mrow( mo( 'lim'), shift()), mrow( shift)); },
    over        => sub { mfrac( mrows( @_));  },
    power       => sub { msup( mrows( @_));   },
    sn          => sub { if( $format=~ m{i1i}) { op( 'E', @_); }
                          else                 { mrow( shift() . mo( '×') , msup( mi(10), shift())); } 
                       },
    plus        => sub { # if next mo is a -, the + is not used
                         my $plus= op( '+',   @_);
                         $plus=~ s{<mo>\+</mo>((<mrow>)*<mo>-</mo>)}{$1}g; # frame oddity: a - is done by plus[minus{
                         return $plus;
                       },
    minus       => sub { u_or_n_nary( '-'      => @_); },
    diff        => sub { my $op= $format && $format eq 'n'? '∂' : 'd'; op( $op, @_); },
    grad        => sub { if( @_ == 1) { pre_op( '∇', @_); }
                         else         { mrow( msub( mo('∇'), $_[1]), $_[0]); }
                       },
    log         => sub { if( @_ == 1) { pre_op( log => @_); }
                         else         { mrow( msub( mo('log'), $_[1]), $_[0]); }
                       },
    oppartial   => sub { if( @_ == 1) { mfrac( mrow( mo( '∂')), mrow( mo('∂'), mi( $_[0]))); }
                         else         { mfrac( mrow( msup( mo( '∂'), $_[1])), mrow( mo('∂'), mi( $_[0]))); }
                       },
    optotal     => sub { if( @_ == 1) { mfrac( mrow( mo( 'd')), mrow( mo('d'), mi( $_[0]))); }
                         else         { mfrac( mrow( msup( mo( 'd'), $_[1])), mrow( mo('d'), mi( $_[0]))); }
                   },
    sqrt        => sub { if( @_ == 1) { msqrt( @_); }
                         else         { mroot( @_); }
                       },
    substitution => sub { if(    @_ == 1) { post_op( shift(), '|'); }
                          elsif( @_ == 2) { msub( mrow( shift(), mo( '|')), shift()); }
                          else            { msubsup( shift() . mo( '|'), @_); }
                        },
    # seems to be used instead of subsup: the expression, then atop for the sub and sup
    # so with 2 attributes we make it an mfrac, with more a 1-column matrix
    atop        => sub { #if( @_ == 2) 
                         #  { mfrac( { linethickness => 0 }, @_); }
                         #else
                           { mtable( { columnalign => 'left' }, map { mtr( mtd( $_)) } @_); }
                       },
    # prompt => sub { mo( '⋮'); }, # prompt seems to be a single char: ⋮

  );


# p 186-194 of the MIF reference Manual

# these nodes are displayed as the name of the node followed by the content
my @lit= qw( acos acosh acot acoth acsc acsch arg asec asech asin atan atanh
             cos cosh cot coth csc csch exp imag ln real sec sech sgn sin sinh
             tan tanh
            );

# these nodes are displayed as a prefix ( different from the name of the node) followed by the content
# the data is <name> => <prefix>
my %pre_op= ( angle => '∠', box => '□', boxdot => '□⋅',
              change => '∆', curl => '∇⨉', diff => 'd',
              diver => '∇⋅', exists => '∃', forall => '∀',
              neg => '¬', partial => '∂', pm => '±', 
              semicolon => ';', therefore => '∴', ucomma => ',', uequal => '=',
              var => 'δ',
              
            ); 

# these nodes are displayed as the content wrapped between a prefix and a suffix
# the data is <name> => [ <prefix>, <suffix> ]
my %wrap = ( abs   => [ '|', '|' ], bra    => [ '‹', '|' ],
             ceil  => [ '⌈', '⌉' ], dangle => [ '‹', '›' ],
             floor => [ '⌊', '⌋' ], ket    => [ '|', '›' ], 
             norm  => [ '‖'. '‖' ],                             # (sometimes!) appears as 1 bar in my editor, should be 2, alt: ∥ 
           );

# these nodes are displayed as the content, followed by a suffix
# the data is <name> => <suffix>
my %post_op= ( dagger => $ent{dagger}, fact => '!', );

# these nodes are displayed as the list of contents, separated by an operator
# data is <name> => <operator>
my %nary=( approx => '≈', cap => '∩', cdot => '⋅', comma => ',', cong => '≅', cup => '∪', equal => '=',
           equiv => '≡', geq => '≥', gg => '»',  greaterthan => '&gt;', in => '∈',  jotdot => '◊', 
           leftarrow => '←', Leftarrow => '⇐', leq => '≤', lessthan => '&lt;', list => ' ', ll => '«',
           lrarrow => '↔', LRarrow => '⇔', ni => '∋', notequal => '≠', notin => '∉', notsubset => '⊄',
           oplus => '⊕', otimes => '⊗', parallel => '||', perp => '⊥', propto => '∝', rightarrow => '→',
           Rightarrow => '⇒', sim => '∼', subset => '⊂', subseteq => '⊆', supset => '⊃', supseteq => '⊇',
           vee => '∨', wedge => '∧',
           # binaries that can be processed as n-ary
           bullet => '•', cross => '×', div => '÷', fract => '⁄'
         );

my %large=( bigcap => '∩', bigcup => '∪', int => '∫', oint => '∫', prod => '∏', sum => '∑');


sub wrap
  { my( $open, $close, $exp)= @_;
    #warn "wrap: open: '$open' - close: '$close' - exp: '$exp'\nreturned: ",  mrow( mo( $open), $exp, mo( $close)), "\n";
    return mrow( mo( $open), $exp, mo( $close)); 
  }

sub pre_op
  { my( $op, $exp)= @_;
    return mrow( mo( $op), $exp);
  }

sub post_op
  { my( $exp, $op)= @_;
    return mrow( $exp, mo($op));
  }


sub init_node_dispatcher
  { my $dp={ %special};
    foreach my $node (@lit)                   { $dp->{$node}= sub { mrow( mo( $node), shift()); }; }
    while( my( $node, $op) = each %pre_op)    { $dp->{$node}= sub { pre_op( $op, @_); };           }
    while( my( $node, $op) = each %post_op)   { $dp->{$node}= sub { post_op( $_[0], $op); };       }
    while( my( $node, $brackets) = each %wrap){ $dp->{$node}= sub { wrap( @$brackets, @_); };      }
    while( my( $node, $op)= each %nary)       { $dp->{$node}= sub { op( $op, @_); };               }
    while( my( $node, $symbol)= each %large)  { $dp->{$node}= sub { sum( $symbol => @_); };        }
    return $dp;
  }


my $dp=init_node_dispatcher();

sub lparen
  { my @lparen=( '(', '[', '{');
    my( $paren_type)= $format=~ m{i(\d)i};
    $paren_type||=0;
    pre_op( $lparen[$paren_type], @_);
  }

sub rparen
  { my @rparen=( ')', ']', '}');
    my( $paren_type)= $format=~ m{i(\d)i};
    $paren_type||=0;
    post_op( @_, $rparen[$paren_type]);
  }

sub tag
  { my $tag= shift;
    my $atts= $_[0] && ref( $_[0]) eq 'HASH' ? atts_string( %{shift()}) : '' ;
    return join '', "<$tag$atts>", @_, "</$tag>"; 
  } 

sub atts_string
  { my %att= @_;
    my $atts= '';
    foreach my $att (sort keys %att)
      { $atts.= qq{ $att="} .escape_att_val( $att{$att}) . qq{"}; }
    return $atts;
  }

sub escape_att_val
  { my( $val)= @_;
    $val=~ s{&}{&amp;}g;
    $val=~ s{<}{&lt;}g;
    $val=~ s{>}{&gt;}g;
    $val=~ s{"}{&quote;}g;
    return $val;
  }

sub escape_pcdata
  { my( $pcdata)= @_;
    $pcdata=~ s{&}{&amp;}g;
    $pcdata=~ s{<}{&lt;}g;
    $pcdata=~ s{>}{&gt;}g;
    return $pcdata;
  }


sub op
  { return mrow( join( mo( shift), @_)); }

sub mrows
  { map { mrow( $_) } @_; }
sub moi    { return tag( mo => { mathvariant => 'italic' }, @_); }

BEGIN 
  { foreach my $elt (qw( mo mi mn mtext mrow msup msub mfrac mover munder msqrt mroot mtable mtr mtd mmultiscripts))
      {  no strict 'refs';
        *{$elt}= sub { tag( $elt => @_); };
      }
  }

sub none        { return '<none/>';        }
sub mprescripts { return '<mprescripts/>'; }
sub hspace      { return qq{<mspace width="$_[0]pt" />};  }
sub vspace      { return qq{<mspace height="$_[0]pt" />}; }

sub mfenced
  { my %atts;
    my @att_names= qw(open close separators);
    if( $_[0] && ref( $_[0]) eq 'ARRAY')
      { @atts{@att_names}= @{shift()}; }
    return tag( mfenced => \%atts, @_);
  }

sub msubsup    { return tag( msubsup => mrows(@_));    }
sub munderover { return tag( munderover => mrows(@_)); }

sub id
  { my $bracket= { 2 => [ '{', '}' ],
                   1 => [ '[', ']' ],
                 };
    my $atts= { separators => '' };
    my( $bracket_type)= $format=~ m{i(\d)i};
    if( $format && $bracket->{$bracket_type})
      { $atts->{open}  = $bracket->{$bracket_type}->[0]; 
        $atts->{close} = $bracket->{$bracket_type}->[1]; 
      }
    return tag( mfenced => $atts => @_);
  }

sub u_or_n_nary
  { my $op= shift;
    if( @_ == 1) { return mrow( mo( $op), $_[0]); }  # unary form
    else         { return op( $op =>   @_);       }  # n-ary form
  }

sub sum
  { my( $glyph, $content, $from, $to)= @_;
    my $int;
    if( defined( $from) && defined( $to))
      { if( $format && $format eq 'i1i') # todo : use attributes to position better
          { $int= msubsup( mo( $glyph), mrow( $from), mrow( $to)); } 
        elsif( $format && $format eq 'i2i') 
          { $int= msubsup( mo( $glyph), mrow( $from), mrow( $to)); } 
        else
          { $int= munderover( mrow( mo( $glyph)), mrow( $from), mrow( $to)); } 
      }
    elsif( defined( $from))
      { if( $format && $format eq 'i1i') # todo : use attributes to position better
          { $int= munder( mo( $glyph), mrow( $from)); } 
        elsif( $format && $format eq 'i2i') 
          { $int= munder( mo( $glyph), mrow( $from)); } 
        else
          { $int= munder( mrow( mo( $glyph)), mrow( $from)); } 
      }
    else
      { $int= mo( $glyph); }
    return mrow( $int . $content);
  }

sub indexes
  { my( $nb_sup, $nb_sub)= (shift(), shift());
    my $base= shift();
    my @sub= splice( @_, 0, $nb_sub);  
    my @sup= @_;
    if( @sub && @sup)
      { return msubsup( $base, mrow( @sub), mrow( @sup)); }
    elsif( @sub)
      { return msub( $base, mrow( @sub)); }
    elsif( @sup)
      { return msup( $base, mrow( @sup)); }
  }

sub chem
  { my( $pre_sub, $post_sub, $pre_sup, $post_sup)= (shift(), shift(), shift(), shift());

    my $exp= shift();

    # order of the indexes: pre_sup, post_sup, pre_sub, post_sub
    my @pre_sup = $pre_sup  ? splice( @_, 0, $pre_sup  ) : ();
    my @post_sup= $post_sup ? splice( @_, 0, $post_sup ) : ();
    my @pre_sub = $pre_sub  ? splice( @_, 0, $pre_sub  ) : ();
    my @post_sub= $post_sub ? splice( @_, 0, $post_sub ) : ();

    if( @_) { die "wrong content for chem element\n", Dump( \@_), "\n"; }

    # math ml wants first pairs of post sub/sup (with none as filler)
    #               then a mprescripts separator
    #               then pairs of pre sub/sup (with none as filler)

    my @indexes;
    while( @post_sub || @post_sup)
      { push @indexes, shift( @post_sub) || none();
        push @indexes, shift( @post_sup) || none();
      }
    if( @pre_sub || @pre_sup)
      { push @indexes, mprescripts(); 
        while( @pre_sub || @pre_sup)
          { push @indexes, shift( @pre_sub) || none();
            push @indexes, shift( @pre_sup) || none();
          }
      }
    return mmultiscripts( $exp, @indexes);
  }

sub tensor
  { my( $positions, $exp)= (shift(), shift());
    my @indexes;
    foreach my $index (@_)
      { my $sup= $positions % 2;
        $positions= int( $positions / 2);
        if( $sup)
          { push @indexes, none(), $index; }
        else 
          { push @indexes, $index, none(); }
      }
    return mmultiscripts( $exp, @indexes);
  }

sub matrix
  { my( $rows, $columns)= (shift, shift);
    #warn "in matrix ($rows, $columns)\n";
    my @rows;
    foreach (1..$rows) 
      { push @rows, mtr( map { mtd( $_) } splice( @_, 0, $columns)); }
    my $matrix= mtable( @rows);
    if( $format!~ m{i1i}) { $matrix= mfenced( [ '[',']' ], $matrix); }
    return $matrix;
  }


      
sub single_char
  { my ($item)= @_;

    my( $char, $decoration)= $item=~ m{^([^,]*)((?:,[0-4])*)$};
    
    my $ent; # true if the character is an entity
    if( length( $char) > 1 && $ent{$char})
      { $ent= 1;
        $char= $ent{$char};
      }


    my $att= {};

    my $variant= variant( $ent, $format);
    if( $variant) { $att->{mathvariant}= $variant; }

    my $mi= tag( mi => $att => $char);

    if( $decoration) 
      { $decoration=~ s{^,}{};
        my @decoration= split /,/, $decoration;
        return decoration( @decoration, $mi); 
      }
    else            
      { return $mi; }


  }

sub variant
  { my( $ent, $format)= @_;
   $format ||='';

    my %variant; # hints about the font variant used
    if( $ent)                   { $variant{normal}=1; }  # generally, special chars should not be italicized
    if( $format=~ m{"Regular"}) { $variant{normal}=1; }  # frame format
    if( $format=~ m{B"[^"]"B})  { $variant{bold}=1;   }  # B"Regular"B is bold

    if( $variant{normal})
      { if( $variant{bold}) { return 'bold';   }
        else                { return 'normal'; }
      }
    if( $variant{bold})     { return 'bold-italic'; } # by defauld single chars are in italic

  }

sub decoration
  { my( $vector, $prime, $dot, $bar, $underscore, $exp)= @_;
    # for now several decorations on the same expression are not treated specially (no munderover for example)
    if( $vector==1)     { $exp= mover( { accent => 'true' }, $exp, mo('⇀'));  }
    if( $vector==2)     { $exp= mover( { accent => 'true' }, $exp, mo( '^')); }
    if( $vector==3)     { $exp= mover( { accent => 'true' }, $exp, mo( '~')); }
    if( $vector==4)     { $exp= mover( { accent => 'true' }, $exp, mo( '→')); }
    if( $vector==5)     { $exp= mover( { accent => 'true' }, $exp, mo( '⁀')); }
    if( $prime==1)      { $exp= mrow(  $exp, mo( $ent{prime}));    }
    if( $prime==2)      { $exp= mrow(  $exp, mo( $ent{pprime}));   }
    if( $prime==3)      { $exp= mrow(  $exp, mo( $ent{tprime}));   }
    if( $dot==1)        { $exp= mover( $exp, mo( $ent{dot}));      } 
    if( $dot==2)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{twodots}));  } 
    if( $dot==3)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{ellip}));    } 
    if( $bar==1)        { $exp= mover( { accent => 'true' }, $exp, mo( $ent{overline})); }
    if( $underscore==1) { $exp= munder( { accentunder => 'true' }, $exp, mo('~'));            }
    if( $underscore==2) { $exp= munder( { accentunder => 'true' }, $exp, mo('_'));            }
    return $exp; 
  }

sub offset_tweak
  { my( $m, $offset)= @_;
    #warn "processing offset '$offset' for '$m'\n";
    my $points= $offset/65536;
    if( $points >0)      # boundaries are guessed
      { return mrow( msub( mi(''), $m)); }
    elsif( $points >= -6 && $points <= -2)
      { return mrow( msup( mi(''), $m)); }
    else
      { warn "cannot process y offset $offset ($points pt)\n"; }
  }

sub apply_format
  { my( $format, $e)= @_;
    if( my $yoffset= points( $format, 'y')) { $e= apply_yoffset( $yoffset, $e); }
    if( my $lspace= points( $format, 'l'))  { $e= hspace( $lspace) . $e;        }
    if( my $rspace= points( $format, 'r'))  { $e.= hspace( $rspace);            }
    if( $format=~ m{\*C(\d)C\*})            { if( $1 == 1) {$e= uc_content( $e); } }

    return $e;
  }


sub apply_yoffset
  { my( $yoffset, $e)= @_;
    if( $yoffset > 0)
      { return mrow( msub( vspace( $yoffset), $e)); }
    else
      { return mrow( msup( vspace( -$yoffset), $e)); }
  }

sub points
  { my( $format, $code)= @_;
    my $points=0;
    while( $format=~ m{\*$code(-?\d+)$code\*}g) { $points += $1; }
    return $points / 65536;
  }

sub uc_content
  { my( $e)= @_;
    # uc only non tags
    return join( '', map { m{^<} ? $_ : uc } split( /(<[^>]*>)/, $e));
  }

sub replace_frame_escapes
  { my( $s)= @_;
    $s=~ s{\\(x[0-9a-f][0-9a-f] |.)}{ if( $frame_escape{$1}) 
                                        { $1 }
                                      else
                                        { my $code= $1;
                                          if( $code > 0x07) { chr hex $1; }
                                          else             { '';          }
                                        }
                                    }eg;
    $s=~ s{""}{"}g;
    return $s;
  }


}

# the grammar itself 

exp  : ( node | string | num | char | ind |tnum | <error?>)          { $return= $item[1]; 1; }
node : ident '[' format(?) exp(s /,/) ']'           { my $node= $dp->{$item{ident}};
                                                      if( !$node) { warn "unknown node type: $item{ident}\n"; }
                                                      # warn "node: $item{ident}\n";
                                                      # if( $format) { warn "captured: '$item[3]->[0]'\n"; }
                                                      $format= $item[3] ? $item[3]->[0] : '';
                                                      $return= $node->(@{$item[4]});
                                                      $format='';
                                                      1;
                                                    }
string  : 'string' '[' format(?) '"' tstring '"' ']' { my $string= replace_frame_escapes( $item{tstring});
                                                       if( $string=~ m{^\s+$})
                                                         { $return= hspace( 8 * length( $string)); }
                                                       else
                                                         { $return= mtext( escape_pcdata( $string)); }
 
                                                       $format= $item{format} ? $item{format}->[0] : '';
                                                       $return= apply_format( $format, $return);  
                                                       1;
                                                      }
num     : 'num' '[' format(?) tnum ',' '"' tstring '"' ']' { $return= mn( $item{tstring});    
                                                             $format= $item{format} ? $item{format}->[0] : '';
                                                             if( $format=~m{y(-?\d+)y}) { $return= offset_tweak( $return, $1); }
                                                             1;
                                                         }
char    : /(char|dummy)/ '[' format(?) tchar  ']'     { $format= $item{format} ? $item{format}->[0] : ''; 

                                                        $return= $item{tchar};

                                                        # process format
                                                        my %att;

                                                        if( $format=~ m{f"([^"]*)"f})           
                                                          { my $font= $1;
                                                            if( $font eq 'Symbol') # replace the character
                                                              {  $return=~ s{>(.)<}{if( my $s= $symbol{$1}){">$s<"}else{">$1<"}}e; }
                                                            else
                                                              { $att{fontfamily}= $font; }
                                                          }
                                                        if( my $variant= variant( '', $format)) { $att{mathvariant}= $variant; }
  
                                                        if( keys %att)
                                                          { # we need to update the attributes of the char
                                                            my $atts= atts_string( %att);
                                                            $return=~ s{<mi>}{<mi$atts>};
                                                          }
                                                               
                                                        $return= apply_format( $format, $return);
                                                        $format='';
                                                        # warn "returning '$return' for char";
                                                        1;
                                                      }

ident   : /\w+/             { $return= $item[1]; 1; }
tnum    : /[+-]?\d+\.\d+/   { $return= $item[1]; 1; }
tchar   : /[^\]]*/          { $return= single_char( $item[1]); 1; }
ind     : /\d+/             { $return= $item[1]; 1; } # a simple number, used for indices, matrix dimentions...
format  : '(*' /[^*]*/ '*)' { $return= $item[2]; 1; }
tstring : <skip:"">/[^"]*/<skip:$item[1]>           { $return= $item[2]; 1; } # need to change skip so we don't skip over whitespaces
G

my $parser = Parse::RecDescent->new( $grammar) or die "Bad grammar!\n";

foreach my $file (@ARGV)
  { if( $file !~ m{\.mif$}) { next; }
    if( $opt{c} && -f filename( mml => $file)) { next; }

    if( $opt{v}) { warn "processing $file\n"; }

    if( !$opt{n})
      { my $mif= slurp( $file);
        $mif= clean_up_mif( $mif);
        warn "mif: $mif\n" if $opt{v};
        if( ! $mif) 
          { if( $opt{v}) { warn "$file not an equation, skipping.\n"; }
            next;
          }
        my $mml_content= $parser->exp( $mif);
        if( ! $mml_content)
          { my $warning= "could not parse mif\n";
            if( $opt{s}) { die  $warning; }
            else         { warn $warning; }
            next;
          }
        my $mml= qq{<math xmlns="http://www.w3.org/1998/Math/MathML" mathbackground="transparent" displaystyle="true">$mml_content</math>};
        $mml= clean_up_mml( $mml);
        spit( filename( mml => $file), $mml);
        if( $opt{v}) { warn "mml in ", filename( mml => $file), "\n"; } 
      }

    if( $opt{s}) 
      { my $nok= system mml2svg( $file);
        if( $nok && $opt{e}) { die "error in '", join( " ", mml2svg( $file)), "': ", $@; } 
        if( $opt{v}) { warn "svg in ", filename( svg => $file), "\n"; } 
      }

    if( $opt{p}) 
      { my $nok= system svg2png( $file); 
        if( $nok && $opt{e}) { die "error in '", join( " ", svg2png( $file)), "': ", $@; } 
        if( $opt{v}) { warn "png in ", filename( png => $file), "\n"; } 
      }
  }

sub clean_up_mif
  { my( $mif)= @_;
    my $clean_mif='';
    if( $mif=~ m{<MathFullForm `([^']*)'\s*> # end of MathFullForm})
      { $clean_mif= $1; 
        $clean_mif=~ s{[\r\n]}{}g;
        $clean_mif=~ s{prompt\[\s*(\([^)]*\))?\s*\]}{char[⋮]}g; # hack, but the simplest way to deal with nodes with no content
        $clean_mif=~ s{\(\*x.*?\)}{}g; # extr
        $clean_mif=~ s{\(\*l.*?\)}{}g; # hack, but the simplest way to deal with nodes with no content
      }
    return $clean_mif;
  }

sub slurp
  { my $file= shift;
    open( my $in, '<', $file) or die "cannot open input file '$file': $!\n";
    local undef $/;
    my $content= <$in>;
    return $content;
  }

sub spit
  { my $file= shift;
    open( my $out, '>:utf8', $file) or die "cannot create file '$file': $!\n";
    print {$out} @_;
  }

sub filename
  { my( $ext, $file)= @_;
    $file=~ s{\.[^.]+$}{.$ext};
    return $file;
  }

sub clean_up_mml
  { my( $mml)= @_;
    my $t= XML::Twig->new( twig_handlers => { mrow    => \&tmrow,
                                              #wrapper => \&twrapper,
                                              mfenced => \&tmfenced,
                                            },
                           pretty_print => 'indented',
                           error_context => 1,
                         )
         ->parse( $mml);
    return $t->sprint;
  }

sub twrapper
  { my( $t, $wrapper)= @_;
    $wrapper->first_child->set_att( mathvariant => $wrapper->att( 'mathvariant'));
    $wrapper->erase;
  }

sub tmrow
  { my( $t, $mrow)= @_;
    if( $mrow->has_no_atts && ($mrow->children()==1)  && $mrow->children( 'mrow'))
      { $mrow->erase; }
  }

sub tmfenced
  { my( $t, $mfenced)= @_;
    my @children= $mfenced->children;
    my @esep; # separators, to be deleted if they can be replaced by the separator attribute
    my $sep;
    while( @children)
      { shift @children;                 # skip a child
        if( my $esep= shift @children)   # next one should be a mi containing the separator
          { if( $esep->tag ne 'mi') 
              { return; }                # failed, not a mi
            if( ! defined $sep)
              { $sep= $esep->text;       # first separator found, store it to see if they are all alike 
                push @esep, $esep;        #  store the element so we can remove it later
              }
            else
              { if( $esep->text ne $sep)
                  { return; }            # failed: 2 different separators found
                else
                  {  push @esep, $esep; } # still good, store the element so we can remove it later
              }
          }
      }
    if( ! defined $sep) { return; } # no separator, just 1 element in mfenced, should not happen

    # if we get here, we have a success
    $mfenced->set_att( separators => $sep);     # set attribute
    foreach my $esep (@esep) { $esep->delete; } # remove elements
  }

__END__
=head1 NAME

  mif2mml - converts MIF equations into MathML 

=head1 OPTIONS

  -s  generates also an SVG file for each equation 
      (needs math2svg or other converter installed)
  -p  generates also a PNG file for each equation 
      (needs math2svg and inkscape or other converter installed)

  -c  only converts if the MathML file (.mml) does not exist already

  -v verbose

=head1 REQUIREMENTS

  - Perl 5.8+, perl modules XML::Twig and Parse::RecDescent

  - expat 

  -  mathmlsvg (from gtkmathview http://helm.cs.unibo.it/mml-widget/
     there are debian packages for libgtkmathview in sid
     
     alternatively you could use math2svg (L<http://www.grigoriev.ru/svgmath/>) for SVG generation

     those 2 packages are hell to install and configure, especially to get
     the fonts right

  - inkscape for PNG generation (from the SVG, so you also need math2svg)


=head1 SEE ALSO

MIF Reference Online Manual: L<http://www.adobe.com/devnet/framemaker/pdfs/MIF_Reference.pdf>

=head1 AUTHOR

Michel Rodriguez <mirod@cpan.org>
Bug reports and feature requests should be emailed directly to the author.

=head1 LICENSE

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License verion 2.0,
 as published by the Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details at
 L<http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>

